#lang ivy1.8

# Include the order module from standard Ivy library (ivy/include/1.7/order.ivy):

include order

# Create types `count_t`, `time_t`, and `seqnum_t`, which are both unbounded
# sequences:

instance count_t : unbounded_sequence
instance seqnum_t : unbounded_sequence
instance time_t : unbounded_sequence

# Next we define the set of validators and quorums of validators
type validator_t
type nset_t
relation well_behaved(V:validator_t)
relation member(V:validator_t, S:nset_t)
relation is_quorum(S:nset_t)
# This is interesting: it looks like we don't need quorum intersection; the following property is
# enough:
axiom exists V . member(V,Q) & well_behaved(V)
# axiom is_quorum(Q1) & is_quorum(Q2) -> exists V . well_behaved(V) & member(V,Q1) & member(V,Q2)

# State and actions pertaining to Stellar
# =======================================

# The duration of the withdraw period (which starts at time 0):

parameter end_withdraw_period:time_t
axiom end_withdraw_period > 0

# The type of withdraw transactions from the bridge to the receiving account:

object withdraw_t = {
    type this = struct {
        max_time : time_t,
        seqnum : seqnum_t
    }
}


# The last ledger close time on Stellar:

var t:time_t

# History of executed transactions (by ledger close time):

relation executed(T:time_t, TX:withdraw_t)

# Current sequence number of the receiving account:

var seqnum:seqnum_t

# History of the sequence number of the receiving account (by ledger close time):

relation seqnums(T:time_t, S:seqnum_t)

after init {
    t := 0;
    executed(T,TX) := false; # nothing has been executed
    seqnum := 0;
    seqnums(T,S) := T=0 & S=0; # at time 0, the seqnum of the receiving account is 0
}

# A withdrawal is valid and can be executed when its sequence number is equal
# to the successor of the sequence number of the receiving account and its `max_time` is greater
# or equal to the current time. TODO: it should be sequence number + 1.

relation valid(TX:withdraw_t, T:time_t)
definition valid(TX:withdraw_t, T:time_t) =
    seqnum_t.succ(seqnum, withdraw_t.seqnum(TX)) & T <= withdraw_t.max_time(TX)

# Execute a new ledger potentially containing a withdraw transaction. Note that
# the sequence number of the receiving account can increase due to other
# transactions.

export action new_ledger(new_t:time_t, s:seqnum_t, include_withdrawal:bool) = {
    require new_t > t;
    require s >= seqnum;
    if include_withdrawal {
        local tx:withdraw_t {
            require exists Q . is_quorum(Q) & forall V . member(V,Q) -> signed(V,tx);
            require valid(tx, new_t);
            executed(new_t, tx) := true;
            require s > seqnum;
        }
    };
    seqnum := s;
    t := new_t;
    seqnums(t, seqnum) := true;
}

# State and actions pertaining to the bridge
# ==========================================

# The bridge processes Stellar ledgers but may be late. It can also lose its
# state and restart.

# Whether a validator signed a refund:
var refunded(V:validator_t):bool

# signed(v, tx) means that validator v signed transaction tx
relation signed(V:validator_t, TX:withdraw_t)

# Ledger time as seen by each bridge validator:
function validator_ledger_time(V:validator_t): time_t

# Sequence number of the receiving account as seen by each bridge validator:
function validator_receiving_seqnum(V:validator_t): seqnum_t

after init {
    signed(V,TX) := false; # nothing has been signed
    refunded(V) := false; # no refund has been made
    validator_ledger_time(V) := 0;
    validator_receiving_seqnum(V) := 0;
}

# A brigde validator processes ledgers up to `l`.
export action process_ledgers(v:validator_t, l:time_t) = {
    require l <= t;
    validator_ledger_time(v) := l;
    local s:seqnum_t { # the seqnum of the receiving account as of ledger l
        assume seqnums(l, s);
        validator_receiving_seqnum(v) := s;
    }
}

# A bridge validator loses its state and restarts:

export action restart(v:validator_t) = {
    validator_ledger_time(v) := 0;
    validator_receiving_seqnum(v) := 0
}

# A bridge validator signs a withdraw transaction if:
# a) it has not been executed
# according to the validators's view of Stellar (so, before or in ledger
# `validator_ledger_time`),
# b) `max_time` is before the end of the withdraw period, and
# c) the sequence number of the transaction is equal to the receiving account's
# sequence number according to the validator's view.

export action sign_withdraw(v:validator_t, tx:withdraw_t) = {
    require T <= validator_ledger_time(v) -> ~executed(T, TX);
    require tx.max_time <= end_withdraw_period;
    require seqnum_t.succ(validator_receiving_seqnum(v), tx.seqnum);
    signed(v,tx) := true;
}

# A bridge validator refunds a transaction if we are past the end of the withdraw period (as measure by Stellar ledger time as seen by the bridge) and no withdraw transaction has been executed.

export action refund(v:validator_t) = {
    require validator_ledger_time(v) > end_withdraw_period;
    require T <= validator_ledger_time(v) -> ~executed(T, TX);
    refunded(v) := true;
}

# this models an attacker taking over a number of bridge validators
export action attack = {
    refunded(V) := *;
    signed(V,TX) := *;
    assume well_behaved(V) -> refunded(V) = old refunded(V);
    assume well_behaved(V) -> signed(V,TX) = old signed(V,TX);
}

isolate canary_1 = {
    private {
        # here we state some properties that, if violated in a bmc run, show that the system does
        # something
        # attribute method=bmc[6]
        # a counter-example to this show that there is a scenario in which a refund is made:
        # invariant ~(is_quorum(Q) & forall V . member(V,Q) -> refunded(V))
    }
} with this

isolate canary_2 = {
    private {
        # here we state some properties that, if violated in a bmc run, show that the system does
        # something
        # attribute method=bmc[6]
        # a counter-example to this show that there is a scenario in which a withdraw is successfully
        # executed:
        # invariant ~executed(T,TX)
    }
} with this

isolate safety_bmc = {
    # attribute method=bmc[15]
    private {
        # invariant ~(is_quorum(Q) & (forall V . member(V,Q) -> refunded(V)) & executed(T,TX))
        # invariant executed(T1, TX1) & executed(T2, TX2) -> T1 = T2 & TX1 = TX2
    }
} with this

# Safety proof
# ============

# Ivy checks that the invariants given are together inductive. This means that:
# a) they hold in the initial state and
# b) if they hold in a state s and we execute an exported action to obtain s',
# then the invariants also hold in s'.
#
# Note that if those two conditions hold then, by induction, the invariants
# hold in every reachable state.

isolate safety_1 = {
    private {

        # A withdrawal cannot be both executed and refunded:
        # --------------------------------------------------

        invariant ~(is_quorum(Q) & (forall V . member(V,Q) -> refunded(V)) & executed(T,TX))

        # Supporting invariants:


        # no withdrawals are executed after the end of the withdraw period:
        invariant executed(T,TX) -> T <= end_withdraw_period
        # refunds only happend after the withdraw period:
        invariant well_behaved(V) & refunded(V) -> t > end_withdraw_period
        # if a refund is issued, no withdraw transaction was executed by the end of the withdraw
        # period:
        invariant well_behaved(V) & refunded(V) & T <= end_withdraw_period -> ~executed(T,TX)
        # the bridge is always behind or in sync:
        invariant well_behaved(V) -> validator_ledger_time(V) <= t
        # all pending withdrawals have a max time lower than `end_withdraw_period`:
        invariant well_behaved(V) & signed(V,TX) -> withdraw_t.max_time(TX) <= end_withdraw_period
    }
} with this

isolate safety_2 = {
    private {

        # No double withdrawals:
        # ----------------------

        invariant executed(T1, TX1) & executed(T2, TX2) -> T1 = T2 & TX1 = TX2

        # Supporting invariants:

        # executed transactions that a bridge validator does not know about have a sequence number strictly higher than the highest sequence number the bridge validator knows about:
        invariant well_behaved(V) & executed(T1,TX1) & T1 > validator_ledger_time(V) -> withdraw_t.seqnum(TX1) > validator_receiving_seqnum(V)
        # an executed withdrawal must have been signed by at least one well-behaved validator
        invariant executed(T,TX) -> exists V . well_behaved(V) & signed(V,TX)
        # if a withdraw is executed, then all the others signed withdraws have stale sequence numbers:
        invariant well_behaved(V) & executed(T1,TX1) & signed(V,TX2) -> withdraw_t.seqnum(TX2) <= seqnum
        # pending transactions have sequence numbers at most one above the current sequence number of
        # the receiving account:
        invariant well_behaved(V) & signed(V,TX) -> (withdraw_t.seqnum(TX) <= seqnum | seqnum_t.succ(seqnum, withdraw_t.seqnum(TX)))
        # the bridge is in sync or late:
        invariant well_behaved(V) -> validator_receiving_seqnum(V) <= seqnum

        # Properties of Stellar:

        # `seqnum` is the sequence number of the receiving account at the end of the last ledger:
        invariant seqnums(t,seqnum)
        # executed transactions have sequence number at least 1 (since the account starts at 0):
        invariant executed(T,TX) -> withdraw_t.seqnum(TX) > 0
        # no seqnum is assigned in the future:
        invariant seqnums(T,S) -> T <= t
        # sequence numbers only grow:
        invariant seqnums(T1,S1) & seqnums(T2,S2) & T1 < T2 -> S1 <= S2
        # a ledger determines a unique seqnum:
        invariant seqnums(T,S1) & seqnums(T,S2) -> S1 = S2
        # executing a withdrawal strictly increases the sequence number of the receiving account:
        invariant seqnums(T1,S) & executed(T2,TX) & T1 < T2 -> S < withdraw_t.seqnum(TX)
        # seqnums are recorded
        invariant executed(T,TX) -> exists S . seqnums(T,S)

    }
} with this
